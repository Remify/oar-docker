#!/usr/bin/python2 -u
import argparse
import os
import os.path
import re
import signal
import sys
import threading

import errno
import stat


KILL_PROCESS_TIMEOUT = 5
KILL_ALL_PROCESSES_TIMEOUT = 5

LOG_LEVEL_ERROR = 1
LOG_LEVEL_WARN = 1
LOG_LEVEL_INFO = 2
LOG_LEVEL_DEBUG = 3

log_level = None


class AlarmException(Exception):
    pass


def error(message):
    if log_level >= LOG_LEVEL_ERROR:
        sys.stderr.write("*** %s\n" % message)


def warn(message):
    if log_level >= LOG_LEVEL_WARN:
        print("*** %s" % message)


def info(message):
    if log_level >= LOG_LEVEL_INFO:
        print("*** %s" % message)


def debug(message):
    if log_level >= LOG_LEVEL_DEBUG:
        print("*** %s" % message)


def touch(fname, times=None):
    dirname = '/'.join(fname.split('/')[:-1])
    if not os.path.exists(dirname):
        os.makedirs(dirname)
    with file(fname, 'a'):
        os.utime(fname, times)


def ignore_signals_and_raise_keyboard_interrupt(signame):
    signal.signal(signal.SIGTERM, signal.SIG_IGN)
    signal.signal(signal.SIGINT, signal.SIG_IGN)
    raise KeyboardInterrupt(signame)


def raise_alarm_exception():
    raise AlarmException('Alarm')


def listdir(path):
    try:
        result = os.stat(path)
    except OSError:
        return []
    if stat.S_ISDIR(result.st_mode):
        return sorted(os.listdir(path))
    else:
        return []


def is_exe(path):
    try:
        return os.path.isfile(path) and os.access(path, os.X_OK)
    except OSError:
        return False


_find_unsafe = re.compile(r'[^\w@%+=:,./-]').search


def shquote(s):
    """Return a shell-escaped version of the string *s*."""
    if not s:
        return "''"
    if _find_unsafe(s) is None:
        return s

    # use single quotes, and put single quotes into double quotes
    # the string $'b is then quoted as '$'"'"'b'
    return "'" + s.replace("'", "'\"'\"'") + "'"


def waitpid_reap_other_children(pid):
    done = False
    status = None
    try:
        this_pid, status = os.waitpid(pid, os.WNOHANG)
    except OSError as e:
        if e.errno == errno.ECHILD or e.errno == errno.ESRCH:
            return None
        else:
            raise
    while not done:
        this_pid, status = os.waitpid(-1, 0)
        done = this_pid == pid
    return status


def stop_child_process(name, pid, signo=signal.SIGTERM, time_limit=KILL_PROCESS_TIMEOUT):
    info("Shutting down %s (PID %d)..." % (name, pid))
    try:
        os.kill(pid, signo)
    except OSError:
        pass
    signal.alarm(time_limit)
    try:
        try:
            waitpid_reap_other_children(pid)
        except OSError:
            pass
    except AlarmException:
        warn("%s (PID %d) did not shut down in time. Forcing it to exit." % (name, pid))
        try:
            os.kill(pid, signal.SIGKILL)
        except OSError:
            pass
        try:
            waitpid_reap_other_children(pid)
        except OSError:
            pass
    finally:
        signal.alarm(0)


def run_command_killable(*argv):
    filename = argv[0]
    status = None
    pid = os.spawnvp(os.P_NOWAIT, filename, argv)
    try:
        status = waitpid_reap_other_children(pid)
    except BaseException:
        warn("An error occurred. Aborting.")
        stop_child_process(filename, pid)
        raise
    if status != 0:
        if status is None:
            error("%s exited with unknown status\n" % filename)
        else:
            error("%s failed with status %d\n" % (filename, os.WEXITSTATUS(status)))
        sys.exit(1)


def run_startup_files(my_initd_path, level=0):
    # Run /var/lib/container/my_init.d/*
    for name in listdir(my_initd_path):
        filename = os.path.join(my_initd_path, name)
        if is_exe(filename):
            info("Running %s..." % filename)
            run_command_killable(filename)
        elif listdir(filename) and name in os.uname()[1] and level == 0:
            run_startup_files(filename, level + 1)
    if level == 0:
        # Run /etc/rc.local.
        if is_exe("/etc/rc.local"):
            info("Running /etc/rc.local...")
            run_command_killable("/etc/rc.local")


def install_insecure_key():
    info("Installing insecure SSH key for user root")
    run_command_killable("/usr/local/sbin/enable_insecure_key")


def main(args):
    if args.enable_insecure_key:
        install_insecure_key()

    if not os.path.exists("/var/lib/container/ignore_startup_files"):
        run_startup_files("/var/lib/container/my_init.d")

    if args.skip_startup_files_next_time:
        # Ignore this startup files next time
        touch("/var/lib/container/ignore_startup_files")

    if args.remain_after_exit:
        dummy_event = threading.Event()
        dummy_event.wait()

if __name__ == '__main__':
    # Parse options.
    parser = argparse.ArgumentParser(description='Initialize the system.')
    parser.add_argument('--enable-insecure-key', dest='enable_insecure_key',
                        action='store_const', const=True, default=False,
                        help='Install the insecure SSH key')
    parser.add_argument('--skip-startup-files-next-time', dest='skip_startup_files_next_time',
                        action='store_const', const=True, default=False,
                        help='Enable running /var/lib/container/my_init.d/* and /etc/rc.local only once')
    parser.add_argument('--remain-after-exit', dest='remain_after_exit',
                        action='store_const', const=True, default=False,
                        help='The service shall be considered active even when all its processes exited.')
    parser.add_argument('--quiet', dest='log_level',
                        action='store_const', const=LOG_LEVEL_WARN, default=LOG_LEVEL_INFO,
                        help='Only print warnings and errors')
    args = parser.parse_args()
    log_level = args.log_level

    # Run main function.
    signal.signal(signal.SIGTERM, lambda signum, frame: ignore_signals_and_raise_keyboard_interrupt('SIGTERM'))
    signal.signal(signal.SIGINT, lambda signum, frame: ignore_signals_and_raise_keyboard_interrupt('SIGINT'))
    signal.signal(signal.SIGALRM, lambda signum, frame: raise_alarm_exception())
    main(args)
